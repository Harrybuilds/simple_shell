#include "shell.h"


/**
 * display_prompt - Displays the shell prompt
 * Return: nothing is returned
 */

void display_prompt(void)
{
	printf("($) ");
}

/**
 * execute_command - Executes the given command
 * @command: command to be executed
 * Return: nothing is returned
 */
void execute_command(char *command, int count)
{
	char **argv;
	int status;
	pid_t pid;
	char *exec_command;
	char *path;

	if (strcmp(command, "exit") == 0)
	{
		printf("Exiting the shell.\n");
		exit(EXIT_FAILURE);
	}
	else
	{
		path = getenv("PATH");
		/*parse the command using whitespace*/
		exec_command = processcommand(command, path);
		if (exec_command != NULL)
		{
			argv = tokenizestr(exec_command, " ");
			pid = fork();
			if (pid == -1)
			{
				perror("fork");
				exit(EXIT_FAILURE);
			}
			else if (pid == 0)
			{
			/* child  process */
				if (execve(argv[0], argv, NULL) == -1)
				{
					fprintf(stderr, "%s: %d: %s: %s\n", argv[0], count, command, "not found");
					exit(errno);
				}
			}
			else
			{
				printf("status value returned to parent process before free call: %d\n", WEXITSTATUS(status));
			freepointer(exec_command);
			free_2dbuffer(argv);
			/* Parent process */
			parentprocess(pid, status, "./hsh");
			}

		}
		else
		{
			fprintf(stderr,"%s cannot be found\n", command);
			/*return a status code*/
		}
	}
	
}

void parentprocess(pid_t pid, int status, char *command)
{
	if (waitpid(pid, &status, 0) == -1)
	{
		perror("waitpid");
		exit(EXIT_FAILURE);
	}
	if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
	{
		fprintf(stderr, "./hsh: %s: %s\nstatus: %d, errno: %d\n", command, strerror(errno), status, errno);
	}
	else if (WIFSIGNALED(status))
	{
		fprintf(stderr, "./hsh: %s: terminated by signal %d\nstatus: %d errno: %d\n", command, WTERMSIG(status), status, errno);
	}
}

/**
 * main - Entry point for the simple shell program
 * Return: Always 0 on success
 */

int main(void)
{
	char *input = NULL;
	size_t input_size = 0;
	int count = 0;

	while (1)
	{
		display_prompt();

		if (getline(&input, &input_size, stdin) == -1)
		{
			exit(EXIT_SUCCESS);
		}

		input[strcspn(input, "\n")] = '\0';
		count++;
		handlecommandline(input, count);

	}
	freepointer(input);

	return (0);
}

/**
 *handlecommandline - function to parse multiple commands
 *@string: commands passed as strings
 *return: no value is returned
*/
void handlecommandline(char *string, int count)
{

	char *argv[10];
	size_t index = 0;
	char *delim = ";&&";
	char *token;

	token = strtok(string, delim);

	while (token != NULL)
	{
		argv[index] = strdup(token);
		index += 1;
		token = strtok(NULL, delim);
	}
	argv[index] = NULL;

	index = 0;
	while (argv[index] != NULL)
	{
		execute_command(argv[index], count);
		index += 1;
	}
}

#include "shell.h"


/**
 * get_full_path - function to attempt getting the full path of a command
 *@command: the command to attempt verifing it's fullpath
 *@path: path to used for the verification process
 * Return: fullpath of command if valid else NULL
*/
char *get_full_path(const char *command, const char *path)
{
	char *input_command;
	char *full_path;
	char *path_copy;

	if (command == NULL || strlen(command) == 0)
	{
		fprintf(stderr, "Invalid command\n");
		return (NULL);
	}
	if (path == NULL || strlen(path) == 0)
	{
		fprintf(stderr, "PATH environment variable not found\n");
		return (NULL);
	}
	printf("Searching for command: %s\n", command);
	printf("Current PATH: %s\n", path);
	/* Duplicate the command string for manipulation*/
	input_command = strdup(command);
	if (input_command == NULL)
	{
		perror("Error duplicating command");
		exit(EXIT_FAILURE);
	}
	/* Make a copy of PATH for tokenizing*/
	path_copy = strdup(path);
	if (path_copy == NULL)
	{
		perror("Error duplicating PATH");
		freepointer(input_command);
		exit(EXIT_FAILURE);
	}

	full_path = parsepath(path_copy, input_command);

	freepointer(path_copy);
	return (full_path);
}

/**
 * parsepath - focuses on tokenizing the path and validating the path
 *@path_copy: a copy of the path to be used for verification
 *@input_command: a copy of the command passed
 * Return: a valid fullpath or NULL
*/
char *parsepath(char *path_copy, char *input_command)
{
	char *token;
	char *full_path;
	int full_path_len;

	token = strtok(path_copy, ":");
	while (token != NULL)
	{
		/* Construct the full path*/
		full_path_len = strlen(token) + strlen(input_command) + 2;
		full_path = malloc(full_path_len); /* Allocate memory for full path*/
		if (full_path == NULL)
		{
			perror("Error allocating space");
			exit(EXIT_FAILURE);
		}
		snprintf(full_path, full_path_len, "%s/%s", token, input_command);
		printf("Checking path: %s\n", full_path);
		/* Check if the file exists*/
		if (access(full_path, F_OK) == 0)
		{
			return (full_path);
		}
		/* Clean up and move to the next directory in PATH*/
		free(full_path);
		token = strtok(NULL, ":");
	}

	return (NULL);
}


/***int main() {
    char *line = NULL;
    size_t len = 0;
    ssize_t read;

    printf("Enter a command (or 'exit' to quit):\n");

    while (1) {
        printf("> ");
        read = getline(&line, &len, stdin);

        if (read == -1) {
            printf("Error reading input\n");
            break;
        }

        // Remove newline character if present
        if (line[read - 1] == '\n') {
            line[read - 1] = '\0';
            read--;
        }

        if (strcmp(line, "exit") == 0) {
            printf("Exiting...\n");
            break;
        }

        char *path = getenv("PATH");
        char *full_path = get_full_path(line, path);
        if (full_path != NULL) {
            printf("Full path: %s\n", full_path);
            free(full_path);
        } else {
            printf("Command '%s' not found\n", line);
        }

        printf("Enter another command (or 'exit' to quit):\n");
    }

    free(line);
    return 0;
}
*/
#include "shell.h"

/**
 *processcommand - function to modify commands
 *@string: string to be modified
 *Return: a char pointer
*/
char *processcommand(char *string, char *path)
{
	char *fullpath;
	char *token;
	char *cpy;
	char *newstr;
	char *new_sub;

	newstr = handlewhitespace(string);

	if (strncmp(newstr, "/bin/", 5) == 0)
	{
		token = strtok(strdup(newstr), " ");
		printf("token: %s\n",token);
		new_sub = extract_substring(token);
		fullpath = get_full_path(new_sub, path);
		printf("Full path: %s\n", fullpath);
		if (token == fullpath)
		{
			freepointer(new_sub);
			freepointer(fullpath);
			return (newstr);
		}
		else
		{
			errno = 2;
			freepointer(new_sub);
			return (fullpath);
		}
		
	}
	else
	{
		cpy = malloc(strlen(newstr) + 6);
		strcpy(cpy, "/bin/");
		strcat(cpy, newstr);

		token = strtok(strdup(cpy), " ");
		fullpath = get_full_path(newstr, path);
		if (token == fullpath)
		{
			free(fullpath);
			return (cpy);
		}
		else
		{
			freepointer(newstr);
			errno = 2;
			freepointer(cpy);
			return (fullpath);
		}
		
	}

}




/**
 * tokenizestr - function to parse a string into 2d array
 * @str: string to be parsed
 * @delim: delimeter to be used for parsing the string
 * Return: a 2d array pointer pointing to the parsed string
*/

char **tokenizestr(char *str, char *delim)
{
	char **argv;
	int index = 0;
	char *token;

	argv = malloc(MAX_ARGUMENT * sizeof(char *));
	if (argv == NULL)
	{
		perror("failure to allocate memory");
		exit(EXIT_FAILURE);
	}

	token = strtok(str, delim);
	while (token != NULL && index < MAX_ARGUMENT - 1)
	{
		argv[index] = strdup(token);
		index += 1;
		token = strtok(NULL, delim);
	}
	argv[index] = NULL;

	return (argv);
}



/**
 *free_2dbuffer - free the 2d array holding all parts of command
 *@args: 2d array holding the tokenized commands
 *
 *Return: no value is returned
 */


/* Function to free the memory allocated for parsed command arguments*/
void free_2dbuffer(char **args)
{
	int i;

	if (args == NULL)
		return;

	for (i = 0; args[i] != NULL; i++)
	{
		free(args[i]);
	}
	free(args);
}


/**
 * handlewhitespace - function to fix whitespace
 * @str: string in which whitespace is removed
 * Return: new fixed string without leading and trailing whitespace
*/

char *handlewhitespace(char *str) {
    if (str == NULL || *str == '\0') {
        return strdup("");  // Return an empty string if input is NULL or empty
    }

    const char *start = str;
    const char *end = str + strlen(str) - 1;

    // Trim leading whitespace
    while (isspace(*start)) {
        start++;
    }

    // Check if the string is all whitespace
    if (*start == '\0') {
        return strdup("");  // Return an empty string if the entire string is whitespace
    }

    // Trim trailing whitespace
    while (end > start && isspace(*end)) {
        end--;
    }

    // Calculate the length of the trimmed substring
    size_t length = end - start + 1;

    // Allocate memory for the trimmed substring
    char *trimmed_str = (char *)malloc(length + 1); // +1 for the null-terminator
    if (trimmed_str == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    // Copy the trimmed substring to the new memory location
    strncpy(trimmed_str, start, length);
    trimmed_str[length] = '\0'; // Null-terminate the string

    return (trimmed_str);
}


/**
 *freepointer - function to free dynamic allocated space
 *@ptr: character pointer to be freed
 *return: nothing is returned
*/

void freepointer(char *ptr)
{
	free(ptr);
}


char *extract_substring(const char *str)
{
    const char *prefix = "/bin/";
    size_t prefix_len = strlen(prefix);

    // Check if the string starts with the prefix "/bin/"
    if (strncmp(str, prefix, prefix_len) == 0) {
        // Return the substring after the prefix "/bin/"
        return strdup(str + prefix_len);
    }

    // If the prefix is not found, return NULL or an appropriate message
    return NULL;
}
